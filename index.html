<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Sechelt</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<meta content="Josh Carpenter%0DMr.doob%0Dâ€”%0Dthree.js, Cinema 4D" name="description">
		<style>
			html, body {
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<script src="js/three.min.js"></script>
		<script src="js/tween.min.js"></script>
		<script src="js/VRControls.js"></script>
		<script src="js/VREffect.js"></script>
		<script src="js/C4DCurveLoader.js"></script>
		<script src="js/webvr-polyfill.js"></script>
		<script src="js/webvr-manager.js"></script>
		<script src="js/lib/utils.js"></script>
		<script src="js/lib/vruikit.js"></script>
		<script src="js/sketch2three.js"></script>
		<script>

		var parameters = ( function () {
			var parameters = {};
			var parts = window.location.search.substr( 1 ).split( '&' );
			for ( var i = 0; i < parts.length; i ++ ) {
				var parameter = parts[ i ].split( '=' );
				parameters[ parameter[ 0 ] ] = parameter[ 1 ];
			}
			return parameters;
		} )();

		var camera, scene, renderer;
		var controls, effect;
		var controls2, clock = new THREE.Clock();
		var sky, water;
		var cameraPath;
		var dolly;
    var manager;

		function init() {

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.autoClear = false;
			renderer.setClearColor( 0x404040 );

			document.body.appendChild( renderer.domElement );

			scene = new THREE.Scene();
			scene.fog = new THREE.Fog( 0xcacfde, 0, 10000 );


			camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 20000 );
			camera.position.z = 0.0001;


			dolly = new THREE.Group();
			dolly.position.set( 10000, 10000, 10000 );

			scene.add( dolly );

			dolly.add( camera );

			// Effect and Controls for VR
			effect = new THREE.VREffect( renderer );
			controls = new THREE.VRControls( camera );

      onWindowResize();

      manager = new WebVRManager(effect); // Initialize the WebVR manager.


			// Create skybox

			var geometry = new THREE.SphereGeometry( 10000, 64, 32 );

			var vertices = geometry.vertices;
			var faces = geometry.faces;

			var colorTop = new THREE.Color( 0xdc72aa );
			var colorMiddle = new THREE.Color( 0xfbdfd3 );
			var colorBottom = new THREE.Color( 0xdc72aa );

			for ( var i = 0, l = faces.length; i < l; i ++ ) {
				var face = faces[ i ];

				var vertex1 = vertices[ face.a ];
				var vertex2 = vertices[ face.b ];
				var vertex3 = vertices[ face.c ];

				var color1 = colorMiddle.clone();
				color1.lerp( vertex1.y > 0 ? colorTop : colorBottom, Math.abs( vertex1.y ) / 6000 );

				var color2 = colorMiddle.clone();
				color2.lerp( vertex2.y > 0 ? colorTop : colorBottom, Math.abs( vertex2.y ) / 6000 );

				var color3 = colorMiddle.clone();
				color3.lerp( vertex3.y > 0 ? colorTop : colorBottom, Math.abs( vertex3.y ) / 6000 );

				face.vertexColors.push( color1, color2, color3 );

			}

			var material = new THREE.MeshBasicMaterial( {
				//vertexColors: THREE.VertexColors,
				side: THREE.BackSide,
				depthWrite: false,
				depthTest: false,
				fog: false,
				map: THREE.ImageUtils.loadTexture( 'images/bg-2.png' )
			} );

			sky = new THREE.Mesh( geometry, material );
			scene.add( sky );


			// Create waves

			var geometry = new THREE.Geometry();

			var vertices = geometry.vertices;
			var faces = geometry.faces;

			var vector = new THREE.Vector3();

			for ( var i = 0; i < 10000; i ++ ) {

				vector.x = Math.random() * 40000 - 20000;
				vector.z = Math.random() * 40000 - 20000;

				var size = Math.random() * 10 + 1;
				var angle = Math.random() * Math.PI;

				var vertex1 = vector.clone();
				vertex1.x += size * Math.cos( angle );
				vertex1.z += size * Math.sin( angle );

				angle -= 2;

				var vertex2 = vector.clone();
				vertex2.x += size * Math.cos( angle );
				vertex2.z += size * Math.sin( angle );

				angle -= 2;

				var vertex3 = vector.clone();
				vertex3.x += size * Math.cos( angle );
				vertex3.z += size * Math.sin( angle );

				var a = vertices.push( vertex1 ) - 1;
				var b = vertices.push( vertex2 ) - 1;
				var c = vertices.push( vertex3 ) - 1;

				faces.push( new THREE.Face3( a, b, c ) );

			}

			var material = new THREE.MeshBasicMaterial( { opacity: 0.4, transparent: true } )

			var mesh = new THREE.Mesh( geometry, material );
			mesh.position.y = 2.5;
			mesh.renderDepth = 1;
			scene.add( mesh );


			// Water texture

			// Causes massive jank and out-of-memory errors, so I abandoned this approach for time being...
			/*
			var texture = THREE.ImageUtils.loadTexture( 'images/waves-2.png' );
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set( 40, 40 );
			var geometry = new THREE.PlaneGeometry( 10000, 10000, 1000, 1000 );
			var material = new THREE.MeshBasicMaterial( {
				//color: 0xffffff,
				map: texture
			} );
			water2 = new THREE.Mesh( geometry, material );
			water2.position.y = 3;
			water2.rotation.x = - Math.PI / 2;
			scene.add( water2 );
			*/


			// Create water

			var geometry = new THREE.PlaneBufferGeometry( 100000, 100000 );
			var material = new THREE.MeshBasicMaterial( {
				color: colorMiddle,
				opacity: 0.75,
				transparent: true
			} );
			water = new THREE.Mesh( geometry, material );
			water.position.y = 0;
			water.rotation.x = - Math.PI / 2;
			water.renderDepth = 2;
			scene.add( water );


			// Create lights

			var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.15 );
			directionalLight.position.set( -1, 1, -1 );
			scene.add( directionalLight );

			var hemisphereLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.8 );
			hemisphereLight.position.set( -1, 2, 1.5 );
			scene.add( hemisphereLight );








			/* ============== Create introduction elements ==============*/


			window.introContainer = new THREE.Group();
			// Make background element

			var geometry = new THREE.SphereGeometry( 10, 20, 20, 0, 360 * Math.PI/180, 0, 90 * Math.PI/180 );
		  var material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 0x26324F });
		  var top = new THREE.Mesh( geometry, material );
		  var bottom = new THREE.Mesh( geometry, material );
		  bottom.rotation.set(0, 0, 1 * Math.PI)

		  introContainer.add( top );
			introContainer.add( bottom );


			// Make "Built with webgl"

			var w = 2,
				h = 0.4;

			var builtwith = new VRUIKit.makeCurvedPlane( w, h, 2 );

			var builtwith_label = new VRUIKit.TextLabel( "BUILT WITH WEBGL\n& FIREFOX NIGHTLY",
			{
				width: w,
				height: h,
				font: 'normal 140px montserrat',
				textAlign: 'left',
				lineHeight: 140,
				verticalAlign: 'middle',
				color: 'white',
				fontPosition: { x: 0, y: 0 }
				// background: 'rgba( 205, 54, 149,1 )'
			})

			// var builtwith_mat = new THREE.MeshBasicMaterial( { side: THREE.FrontSide, transparent: true, opacity: 1, map: welcome_label.mesh.material.map } );
			builtwith.material.transparent = true;
			builtwith.material.opacity = 1;
			builtwith.material.map = builtwith_label.mesh.material.map;
			builtwith.position.set( 0, 0.45, 0 )

			introContainer.add( builtwith );


			// new THREE.TextureLoader().load(
		 //    "images/alpha-2pxblack-leftright.png",
		 //    function( tex )
		 //    {
		 //      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
		 //      tex.repeat.set( 1, 1 );
		 //      tex.offset.set( -1, 0 );
		 //      tex.magFilter = tex.minFilter = THREE.NearestFilter;
		 //      mesh.material.alphaMap = tex;
		 //      mesh.material.needsUpdate = true;

		 //    // 	new TWEEN.Tween( tex.offset )
			// 			// .to( { x: 0 }, 1000 )
			// 			// .easing( TWEEN.Easing.Sinusoidal.Out )
			// 			// .start();

		 //    } );


			// Make "Welcome to the vr web"

			var w = 2,
				h = 0.2;

			var welcome_plane = new VRUIKit.makeCurvedPlane( w, h, 2 );
			var welcome_label = new VRUIKit.TextLabel( "WELCOME TO THE VR WEB",
			{
				width: w,
				height: h,
				font: 'normal 80px montserrat',
				textAlign: 'left',
				verticalAlign: 'middle',
				color: 'white',
				fontPosition: { x: 40, y: 0 }
				// background: 'rgba( 205, 54, 149,1 )'
			})

			//create materials
			var welcome_label_mat = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide, transparent: true, opacity: 1, map: welcome_label.mesh.material.map } );
			var welcome_plane_mat = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide, transparent: false, opacity: 1, color: 0xCD3695 } );
			welcome_materials = [ welcome_label_mat, welcome_plane_mat ];

			//create mesh
			var welcome = THREE.SceneUtils.createMultiMaterialObject( welcome_plane.geometry, welcome_materials );
			// welcome.position.set( 0, 0, -1 )
			introContainer.add( welcome );

			//dolly.add(camera)

			var geometry = new THREE.BoxGeometry( 3,3, 3 );
			var material = new THREE.MeshBasicMaterial( {color: 0x00ff00, wireframe: true} );
			var cube = new THREE.Mesh( geometry, material );
			cube.position.z = -10;

			dolly.add( introContainer );

			// Make border

			var border = VRUIKit.makeBorder(3, 1.5, 0.01, 225, 90, 0, 0xFFFFFF, 1);
			//dolly.add( border );


			// Animate introduction

			function animateIntro(){

				// welcome.children[1].scale.set( 1, 0, 1 );
				// new TWEEN.Tween( welcome.children[1].scale )
				// 	.to( { y: 1 }, 1500 )
				// 	.easing( TWEEN.Easing.Quintic.Out )
				// 	.delay( 1000 )
				// 	.start();

				new TWEEN.Tween( top.rotation )
					.to( { x: 1.57 }, 3000 )
					.delay( 2000 )
					.easing(TWEEN.Easing.Quintic.In)
					.start();

				new TWEEN.Tween( top.scale )
					.to( { x: 0.005, y: 0.005, z: 0.005 }, 3000 )
					.delay( 2000 )
					.easing(TWEEN.Easing.Quintic.In)
					.start();

				new TWEEN.Tween( top.position )
					.to( { z: 2 }, 6000 )
					.delay( 2000 )
					.easing(TWEEN.Easing.Quintic.In)
					.onComplete( function(){ introContainer.remove( top ) } )
					.start();


				new TWEEN.Tween( bottom.rotation )
					.to( { x: -1.57 }, 3000 )
					.delay( 2000 )
					.easing(TWEEN.Easing.Quintic.In)
					.start();

				new TWEEN.Tween( bottom.scale )
					.to( { x: 0.005, y: 0.005, z: 0.005 }, 3000 )
					.delay( 2000 )
					.easing(TWEEN.Easing.Quintic.In)
					.start();

				new TWEEN.Tween( bottom.position )
					.to( { z: 2 }, 3000 )
					.delay( 2000 )
					.easing(TWEEN.Easing.Quintic.In)
					.onComplete( function(){ introContainer.remove( bottom ) } )
					.start();


				// console.log( welcome.children[0] );

			}






			/* ============== Load sketch2three elements ==============*/

			/*
		  function animateStuff(){ //gets called at end of loadSketch

		    for( i = 0; i < elements.length; i++ ){

		      element = elements[i];

		      //if( element.name.indexOf("fav") !== -1 ) { //find all elements with "fav" in the name

		        element.position.setY( element.position.y + 1 );
		        var tween = new TWEEN.Tween( element.position )
		          .to( { y:"-1" }, 2500 )
		          .easing(TWEEN.Easing.Cubic.Out)
		          .delay( i*25 )
		          .start();
		      //}
		    }

		  }

			function bend( group, amount, multiMaterialObject ) {
		    function bendVertices( mesh, amount, parent ) {
		      var geometry = mesh.geometry;

		      if (!mesh.userData.geometry) {
		        mesh.userData.geometry = geometry.clone();
		      } else {
		        mesh.geometry = mesh.userData.geometry.clone();
		        mesh.geometry.verticesNeedUpdate = true;
		      }

		      var vertices = mesh.geometry.vertices;

		      if (!parent) {
		        parent = mesh;
		      }

		      for (var i = 0; i < vertices.length; i++) {
		        var vertex = vertices[i];

		        // apply bend calculations on vertexes from world coordinates
		        parent.updateMatrixWorld();

		        var worldVertex = parent.localToWorld(vertex);

		        var worldX = Math.sin( worldVertex.x / amount) * amount;
		        var worldZ = - Math.cos( worldVertex.x / amount ) * amount;
		        var worldY = worldVertex.y;

		        // convert world coordinates back into local object coordinates.
		        var localVertex = parent.worldToLocal(new THREE.Vector3(worldX, worldY, worldZ));
		        vertex.x = localVertex.x;
		        vertex.z = localVertex.z;
		        vertex.y = localVertex.y;
		      };

		      mesh.geometry.computeBoundingSphere();
		      mesh.geometry.verticesNeedUpdate = true;
		    }

		    for ( var i = 0; i < group.children.length; i ++ ) {
		      var element = group.children[ i ];

		      if (element.geometry.vertices) {
		        if (multiMaterialObject) {
		          bendVertices( element, amount, group);
		        } else {
		          bendVertices( element, amount);
		        }
		      }
		    }

		    if (group.children.length == 0) {
		      bendVertices(group, amount);
		    }
		  };

		  var opts = {
				pixelScale: 0.0035,
				artboardWidth: 3600,
				artboardHeight: 900,
				exclude: [],
				depth: 2
			}

			var s23 = Sketch2three.load('images/s23/index.json', opts)
				.then(function(meshes) {

					var xOffset = -(opts.artboardWidth / 2 * opts.pixelScale);
					var yOffset = (opts.artboardHeight / 2 * opts.pixelScale);

					var group = new THREE.Group();

					meshes.forEach(function(mesh) {
						//self.layout.add(mesh);
						mesh.position.x += xOffset;
						mesh.position.y += yOffset;

						group.add( mesh );

					});

					scene.add(group);
					bend( group, opts.depth );
					group.scale.set( 10, 10, 10 );
					group.position.set( -170, 0, -7420 );


					function getMeshes(meshes, search) {
			      return meshes.filter(function(mesh) {
			        return mesh.name.indexOf(search) > -1
			      });
			    }

					var m = getMeshes(meshes, 'darken');
					m[0].scale.x *= 1.1;
					m[0].scale.y *= 1.1;
					m[0].scale.z *= 1.1;
					m[0].material.visible = false;


					// m[0].scale.set( 1, 0.2, 1 );

					console.log(m[0]);
				});

			*/










			/* ============== Load scene ==============*/

			var loadScene = new THREE.ObjectLoader();
			loadScene.load( 'models/scene-nov4.json', function ( object ) {

				window.setTimeout( animateIntro, 2000 );

				var land = object.getObjectByName( 'land' ).children[0];
				var reflection = new THREE.Mesh( land.geometry, land.material.clone() );
				reflection.material.side = THREE.BackSide;
				reflection.position.y = 0;
				reflection.scale.y = -1;
				land.parent.add( reflection );

				var island = object.getObjectByName( 'island' ).children[0];
				var reflection = new THREE.Mesh( island.geometry, island.material.clone() );
				reflection.material.side = THREE.BackSide;
				reflection.position.y = 0;
				reflection.scale.y = -1;
				island.parent.add( reflection );

				var rocks = object.getObjectByName( 'rocks' ).children[0];
				var reflection = new THREE.Mesh( rocks.geometry, rocks.material.clone() );
				reflection.material.side = THREE.BackSide;
				reflection.position.y = 0;
				reflection.scale.y = -1;
				rocks.parent.add( reflection );

				var trees = object.getObjectByName( 'trees' ).children[0];
				var reflection = new THREE.Mesh( trees.geometry, trees.material.clone() );
				reflection.material.side = THREE.BackSide;
				reflection.position.y = 0;
				reflection.scale.y = -1;
				trees.parent.add( reflection );

				scene.add( object );



				// Create sounds

				/*
					var listener = new THREE.AudioListener();
					camera.add( listener );

					var sound = new THREE.Audio( listener );
					sound.load( 'sounds/78389__inchadney__seagulls.ogg' );
					sound.position.set( 475, 50, 850 );
					sound.setLoop( true );
					sound.setRefDistance( 100 );
					scene.add( sound );

					var sound = new THREE.Audio( listener );
					sound.load( 'sounds/23707__hazure__seagull.ogg' );
					sound.position.set( 10, 50, -200 );
					sound.setLoop( true );
					sound.setRefDistance( 100 );
					scene.add( sound );

					var sound = new THREE.Audio( listener );
					sound.load( 'sounds/235428__allanz10d__calm-ocean-breeze-simulation.ogg' );
					sound.position.set( -30, 0, -750 );
					sound.setLoop( true );
					sound.setRefDistance( 100 );
					scene.add( sound );
				*/

				// Load camera path

				var loadCameraPath = new THREE.C4DCurveLoader();
				loadCameraPath.load( 'models/flightpath-nov4-bezier.txt', function ( curve ) {

					cameraPath = curve.toLinearCurve( 1 ); // 1 = distance between points


					// debug points

					// var geometry = new THREE.Geometry();
					// geometry.vertices = cameraPath.getPoints();
					// var material = new THREE.PointCloudMaterial( { size: 0.1 } );

					// var points = new THREE.PointCloud( geometry, material );
					// points.position.y = -1;
					// points.scale.z = -1;
					// scene.add( points );

					// // debug line

					// var geometry = new THREE.Geometry();
					// geometry.vertices = cameraPath.getPoints();
					// var material = new THREE.LineBasicMaterial();

					// var line = new THREE.Line( geometry, material );
					// line.position.y = -1;
					// line.scale.z = -1;
					// scene.add( line );


					requestAnimationFrame( animate );

				} );

			} );

			window.addEventListener( 'resize', onWindowResize, false );
			//document.body.addEventListener('click', togglePlay);
		}

		// Explode objects function

		function explode( geometry, material ) {

			var group = new THREE.Group();

			for ( var i = 0; i < geometry.faces.length; i ++ ) {

				var face = geometry.faces[ i ];

				var vertexA = geometry.vertices[ face.a ].clone();
				var vertexB = geometry.vertices[ face.b ].clone();
				var vertexC = geometry.vertices[ face.c ].clone();

				var geometry2 = new THREE.Geometry();
				geometry2.vertices.push( vertexA, vertexB, vertexC );
				geometry2.faces.push( new THREE.Face3( 0, 1, 2 ) );

				var mesh = new THREE.Mesh( geometry2, material );
				mesh.position.sub( geometry2.center() );
				group.add( mesh );

			}

			return group;

		}

		var playing = true;

		function togglePlay() {
			playing = playing == false?true:false;
		};

		function play() {
			playing = true;
		}

		function rewind() {
			currentTime = startTime;
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			effect.setSize( window.innerWidth, window.innerHeight );
		};


		var currentTime = 38000,
			startTime = null;
			gotime = null;

		var speed = 20;


		function animate( time ) {
			requestAnimationFrame( animate );

			TWEEN.update();

			if ( cameraPath !== undefined ) {
				if (!startTime) startTime = time;
				if (!currentTime) currentTime = time;
				if (playing) currentTime += speed;

				gotime = TWEEN.Easing.Sinusoidal.InOut( Math.min( currentTime / 70000, 1 ) ) * 0.9999;

				var pointA = cameraPath.getPointAt( gotime );
				var pointB = cameraPath.getPointAt( Math.min( gotime + 0.0001, 1 ) );

				pointA.z = -pointA.z;
				pointB.z = -pointB.z;

				dolly.position.copy( pointA );
				dolly.lookAt( pointB );
				dolly.rotateY( Math.PI ); // look forward
				dolly.updateMatrixWorld();
			}

			if (controls) {
				controls.update();
			}



			sky.position.copy( dolly.position );

			// water.position.x = dolly.position.x;
			// water.position.z = dolly.position.z;

      //if (manager.isVRMode()) {
        effect.render( scene, camera );
      // } else {
        // renderer.render( scene, camera );
      // }



		}

		init();

		</script>

	</body>
</html>
